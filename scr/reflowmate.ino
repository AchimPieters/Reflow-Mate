// MIT License
//
// Copyright (c) 2021 Achim Pieters
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// For more information go to: https://reflowmate.studiopieters.nl

#include <SPI.h>
#include <Wire.h>

//Load Library and set oled settings ESP32 - GPIO22: SCL - GPI21: SDA
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET -1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

//Load Library and set Thermocouple Amplifier settings
#include <Adafruit_MAX31855.h>
int thermocouple_MISO = 12;  // MISO IO12
int thermocouple_SS = 15;  // SS IO15
int thermocouple_SCLK = 14; // SCLK IO14
Adafruit_MAX31855 thermocouple(thermocouple_SCLK, thermocouple_SS, thermocouple_MISO);

//Load Library and set Rotary Encoder settings
#include "AiEsp32RotaryEncoder.h"
#define ROTARY_ENCODER_A_PIN 32
#define ROTARY_ENCODER_B_PIN 19
#define ROTARY_ENCODER_BUTTON_PIN 25
AiEsp32RotaryEncoder rotaryEncoder = AiEsp32RotaryEncoder(ROTARY_ENCODER_A_PIN, ROTARY_ENCODER_B_PIN, ROTARY_ENCODER_BUTTON_PIN, -1, 4);

// ESP32 Defaults IO2: Onboard Led / status led

#define COOLDOWN_TIME 60
#define PREHEAT_TIME 60
#define REFLOW_TIME 60

const int solidstate = 33;    // IO33
const int temperature_preheat = 150;
const int temperature_reflow = 240;

int temperature_now = 0;
int temperature_next = 0;
int temperature_rotary_encoder = 0;
int temperature_rotary_encoder_old = 0;
String state[] = {"STANDBY", "PREHEAT", "REFLOW", "COOLING"};
int state_now = 0;

int time_count = 0;
int percentage = 0;
int offset = 0;

// Bitmap of ReflowMate logo
const unsigned char ReflowMate_logo [] PROGMEM = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x07, 0xfc, 0x1f, 0xf0, 0x00, 0x0f, 0xb8, 0x00, 0x00, 0x00, 0x38, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x0f, 0xfe, 0x1f, 0xf8, 0x00, 0x0f, 0xb8, 0x00, 0x00, 0x00, 0x38, 0x03, 0x00, 0x02, 0x00, 0x18,
        0x1f, 0xff, 0x1c, 0x7c, 0x00, 0x0e, 0x38, 0x00, 0x00, 0x00, 0x38, 0x07, 0x00, 0x02, 0x00, 0x18,
        0x1f, 0xff, 0x1c, 0x1c, 0x0c, 0x0c, 0x38, 0x18, 0x00, 0x00, 0xbc, 0x05, 0x00, 0x02, 0x00, 0x00,
        0x1f, 0xff, 0x1c, 0x1c, 0x7f, 0x3f, 0xb8, 0xfe, 0x71, 0xe3, 0x34, 0x0d, 0x1f, 0x8f, 0x8f, 0x80,
        0x1f, 0xff, 0x1c, 0x1c, 0xf7, 0xbf, 0xb8, 0xff, 0x31, 0xe7, 0x36, 0x0d, 0x39, 0xc2, 0x19, 0xc0,
        0x00, 0x00, 0x1c, 0x78, 0xe3, 0x8e, 0x39, 0xc7, 0xb9, 0xe7, 0x36, 0x09, 0x30, 0xc2, 0x30, 0xc0,
        0x00, 0x00, 0x1f, 0xf8, 0xc1, 0x8e, 0x39, 0xc3, 0xb9, 0xe7, 0x33, 0x19, 0x00, 0xc2, 0x30, 0x40,
        0x1f, 0xff, 0x1f, 0xf0, 0xff, 0xce, 0x39, 0x83, 0x9b, 0x66, 0x33, 0x11, 0x0f, 0xc2, 0x3f, 0xe0,
        0x1f, 0xff, 0x1c, 0x70, 0xc0, 0x0e, 0x39, 0xc3, 0x9b, 0x36, 0x31, 0x31, 0x3c, 0xc2, 0x20, 0x00,
        0x1f, 0xff, 0x1c, 0x78, 0xe0, 0x0e, 0x39, 0xc3, 0x9b, 0x3e, 0x31, 0xa1, 0x30, 0xc2, 0x30, 0x00,
        0x1f, 0xff, 0x1c, 0x38, 0xe3, 0x8e, 0x39, 0xc7, 0x1f, 0x3e, 0x30, 0xe1, 0x30, 0xc2, 0x30, 0x60,
        0x0f, 0xfe, 0x1c, 0x3c, 0x7f, 0x8e, 0x38, 0xff, 0x0e, 0x3c, 0x30, 0xe1, 0x39, 0xc3, 0x19, 0xc0,
        0x07, 0xfc, 0x1c, 0x1c, 0x3e, 0x0e, 0x38, 0x7c, 0x0e, 0x1c, 0x30, 0xc1, 0x1e, 0xc3, 0x8f, 0x80,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void rotary_onButtonClick()
{
// Debugging line
        Serial.println("Button pressed");
}

void setup() {
        Serial.begin(115000);
// Set rotary encoder settings
        rotaryEncoder.begin();
        rotaryEncoder.setup(
                [] {
                rotaryEncoder.readEncoder_ISR();
        },
                [] {
                rotary_onButtonClick();
        });
        rotaryEncoder.setBoundaries(temperature_preheat, temperature_reflow, false); //minValue, maxValue, circleValues true|false (when max go to min and vice versa)
        rotaryEncoder.setAcceleration(250);

//pinMode(button, INPUT);
        pinMode(solidstate, OUTPUT);
        digitalWrite(solidstate, LOW);

        if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
                Serial.println(F("SSD1306 allocation failed"));
                for(;;); // Don't proceed, loop forever
        }

// Show initial display buffer contents on the screen --
// the library initializes this with an Adafruit splash screen.
        display.display();
        delay(2000); // Pause for 2 seconds

// Clear the buffer
        display.clearDisplay();

// Display bitmap
        display.drawBitmap(0, 0,  ReflowMate_logo, 128, 64, WHITE);
        display.display();

// Draw progressbar
        display.drawRoundRect(3, 40, 122, 5, 3, WHITE);
        display.display();
        for (int progress = 0; progress < 118; progress++) {
                display.fillRoundRect(5, 42, progress, 1, 0, WHITE);
                display.display();
                delay(10);
        }
}

long meter = millis();
long current_time = millis();

void loop() {
        temperature_now = thermocouple.readCelsius();
// Get rotary encoder value
        if (rotaryEncoder.encoderChanged())
        {
                Serial.println(rotaryEncoder.readEncoder());
                temperature_rotary_encoder = rotaryEncoder.readEncoder();
        }

        if (temperature_rotary_encoder != temperature_rotary_encoder_old) {
                int v = 0;
                display.fillScreen(WHITE);
                display.setTextColor(BLACK);
                display.setTextSize(1);
                display.setCursor(X(1, 7), Y(1, 0.1));
                display.println("PREHEAT");
                display.setTextSize(2);
                display.setCursor(X(2, 3), Y(2, 0.5));
                while (v < 100) {
// Get rotary encoder value
                        if (rotaryEncoder.encoderChanged())
                        {
                                Serial.println(rotaryEncoder.readEncoder());
                                temperature_rotary_encoder = rotaryEncoder.readEncoder();
                        }

                        if (temperature_rotary_encoder > temperature_rotary_encoder_old + 1 || temperature_rotary_encoder < temperature_rotary_encoder_old - 1) {
                                display.fillScreen(WHITE);
                                display.setTextSize(1);
                                display.setCursor(X(1, 6), Y(1, 0.1));
                                display.println("REFLOW");
                                display.setTextSize(2);
                                display.setCursor(X(2, 3), Y(2, 0.5));
                                display.println(String(temperature_rotary_encoder));
                                display.display();
                                temperature_rotary_encoder_old = temperature_rotary_encoder;
                                v = 0;
                        }
                        v++;
                        delay(20);
                }
                temperature_rotary_encoder_old = temperature_rotary_encoder;
        }

        if (millis() > meter + 200 || millis() < meter) {
                PrintScreen(state[state_now], temperature_next, temperature_now, time_count, percentage);
                meter = millis();
        }
//Read button - first button presss
        if (digitalRead(ROTARY_ENCODER_BUTTON_PIN) == 1) {
                delay(100);
                int c = 0;
                while (digitalRead(ROTARY_ENCODER_BUTTON_PIN) == 1) {
                        c++;
                        if (c > 150) {
                                digitalWrite(solidstate, LOW);
                                state_now = 0;
                                display.fillScreen(WHITE);
                                display.setTextColor(BLACK);
                                display.setTextSize(2);
                                display.setCursor(X(2, 3), Y(2, 0.5));
                                display.println("STANDBY");
                                display.display();
                                while (digitalRead(ROTARY_ENCODER_BUTTON_PIN) == 1) delay(1);
                                return;
                        }
                        delay(10);
                }

                current_time = millis();
                percentage = 0,
//Read button - first button presss
                state_now++;
                if (state_now == 0) temperature_next = 0;
                else if (state_now == 1) temperature_next = temperature_preheat;
                else if (state_now == 2) temperature_next = temperature_rotary_encoder;
                else if (state_now == 3) temperature_next = 0;
                else if (state_now == 4) {
                        state_now = 0;
                        temperature_next = 0;
                }
        }
//********************* PREHEAT *********************
        if (state_now == 1) {
                regulate_temp(temperature_now, temperature_next);

                percentage = int((float(temperature_now) / float(temperature_next)) * 100.00);
                if (percentage >= 100) {
                        time_count = int((current_time + PREHEAT_TIME * 1000 - millis()) / 1000);
                        if (time_count <= 0) {
                                state_now = 2;
                                current_time = millis();
                                percentage = 0;
                                temperature_next = temperature_rotary_encoder;
                        }
                }
                delay(30);
        }
//********************* REFLOW *********************
        else if (state_now == 2) {
                regulate_temp(temperature_now, temperature_next);

                percentage = int((float(temperature_now) / float(temperature_next)) * 100.00);
                if (percentage >= 100) {
                        time_count = int((current_time + REFLOW_TIME * 1000 - millis()) / 1000);
                        if (time_count <= 0) {
                                state_now = 3;
                                current_time  = millis();
                                percentage = 0;
                                temperature_next = 0;
                        }
                }
                delay(30);
        }
//********************* COOLING *********************
        else if (state_now == 3) {
                digitalWrite(solidstate, LOW);

                time_count = int((current_time + COOLDOWN_TIME * 1000 - millis()) / 1000);
                if (time_count <= 0) {
                        state_now = 0;
                }
        }
        else {
                digitalWrite(solidstate, LOW);
                time_count = 0;
        }
        delay(30);
}

void regulate_temp(int temp, int should) {
        if (should <= temp - offset) {
                digitalWrite(solidstate, LOW);
        }
        else if (should > temp + offset) {
                digitalWrite(solidstate, HIGH);
        }
}

void PrintScreen(String state, int target_temperature, int is_temperature, int tim, int percentage_value) {
// Display the Mode e.g. "STANDBY", "PREHEAT", "REFLOW", "COOLING"
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.setTextSize(1);
        display.setCursor(29, 0);
        display.print(state);
        display.println(" MODE");


//Display the Traget temperature
        display.setCursor(70, 27);
        display.print(" | ");
        String str = String(target_temperature);
        display.print(str);
        display.print(" ");
        display.print((char)247);// degree symbol
        display.print("C");
        //Display the percentage of the task
        if (percentage_value != 0) {
                display.setCursor(29, 50);
                str = String(percentage_value) + " %";
                display.print(str);
                display.print(" | ");
        }
//Display the time in seconds
        if (tim != 0) {
                display.setCursor(80, 50);
                str = String(tim) + " sec";
                display.println(str);
        }
//Display the current temperature
        display.setTextSize(2);
        display.setCursor(10, 22);
        str = String(is_temperature);
        display.print(str);
        display.setTextSize(1);
        display.print(" ");
        display.print((char)247);// degree symbol
        display.setTextSize(2);
        display.print("C");
        display.display();
}

//outputs the X coordinate so that text with n characters is in the middle
int X(int textsize, int n) {
        return (0.5 * (display.width() - textsize * (6 * n - 1)));
}

//outputs the Y coordinate so that text is in the middle
int Y(int textsize, float f) {
        return (f * display.height() - (textsize * 4));
}
